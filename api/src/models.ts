import {
  IContainer,
  IUser,
  ILogLogin,
  IPart,
  IFileData,
  IContainerGroup,
  IPartHistory,
  ILocation,
  IPersonalPickList,
  IRackScannerRecord,
  IAttachment,
} from './types';
import mongoose, { Model, Document } from 'mongoose'
import {Schema} from 'mongoose'



/**
 * User
 */
export const UserSchema = new Schema({
  email: String,
  name: String, // user's full name
  abbr: String, 
  groups: [String], // array of group name, 'guest', 'users', 'visitors', or 'administrators'
  createdAt: Date,
  updatedAt: Date,
  barcode: String,
  defaultPickList: {
    type: Schema.Types.ObjectId,
    ref: 'PersonalPickList'
  },
  dbV1:{
    id:Number,
    admin: Boolean,
    canEdit: Boolean,
  }
});
export interface IUserModel extends IUser, Document{}
export const User:Model<IUserModel> = mongoose.model('User', UserSchema, 'users');

/**
 * LogLogin
 */
export const LogLoginSchema = new Schema({
  operator: {
    type:  Schema.Types.ObjectId,
    ref: 'User',
  },
  operatorName: String,
  type: String,
  sourceIP: String,
  timeStamp: Date,
});
export interface ILogLoginModel extends ILogLogin, Document{}
export const LogLogin:Model<ILogLoginModel> = mongoose.model('LogLogin', LogLoginSchema, 'log_logins');

/**
 * LogOperation
 * level: the important level of operations
 *  - 0: debugging information
 *  - 1: listing or getting data
 *  - 2: exporting data
 *  - 3: adding more data into the database
 *  - 4: modifying data, deleting data,
 *  - 5: change previleges, change user information, and other admin operations
 */
export const LogOperationSchema = new Schema({
  operatorId: Schema.Types.ObjectId,
  operatorName: String,
  type: String,
  level: Number,        
  sourceIP: String,
  timeStamp: Date,
  data: Schema.Types.Mixed,
});
export const LogOperation = mongoose.model('LogOperation', LogOperationSchema, 'log_operations');

/**
 * Part
 */
export const PartSchema = new Schema({
  labName: String,                      // combined "labPrefix" and "labId", e.g. 'YCe1234', redundant information
  labPrefix: String,                    // the first part of labName, e.g. 'YCe'. e means E.coli
  labId: Number,                        // the second part of labName, e.g. 1234, incrementing.
  personalName: String,                 // combined "personalPrefix" and "personalId", e.g. 'YLe123', redundant information
  personalPrefix: String,               // the first part of personalName, e.g. 'YLe', YL is the initial letters of the user's name, e means E.coli 
  personalId: Number,                   // the second part of personalName, e.g. 123, incrementing.
  owner: {                              // the ID of the owner
    type: Schema.Types.ObjectId,
    ref: 'User',
  },
  operators: [{
    type: Schema.Types.ObjectId,
    ref: 'User',
  }],
  ownerName: String,                    // the owner's name, redundant information
  sampleType: String,                   // 'bacterium', 'primer', or 'yeast'
  comment: String,                      // description of this part
  createdAt: Date,                      // database document creation date, generated by the program
  updatedAt: Date,                      // database document updating date, generated by the program
  date: Date,                           // the date of sample creation, not the database document creation date, given by user.
  tags: [String],                       
  content: {
    //primers only
    description: String,
    sequence: String,
    orientation: String,
    meltingTemperature: Number,
    concentration: String,
    vendor: String,
    
    //bacteria only
    plasmidName: String,
    hostStrain: String,

    //yeasts only
    parents: [String],
    genotype: [String],
    plasmidType: String,

    //bacteria and yeasts
    markers: [String],
    // all
    customData: Schema.Types.Mixed,  // any other {key:value} pairs are saved here
  },
  attachments: [{                    
    name: String,                // redundant information
    contentType: String,             // redundant information
    size: Number,                // redundant information
    file: {
      type: Schema.Types.ObjectId,
      ref: 'FileData'
    },   // id in the FileData modal
  }],
  containers: [{
      type: Schema.Types.ObjectId,
      ref: 'Container'
    }],
  dbV1:{                             // old id and user id data from the cailab-database-v1, useless in v2
    id: Number,
    userId: Number,
  },
  // history: Schema.Types.Mixed,      // previous version of this part.
  history: {
      type: Schema.Types.ObjectId,
      ref: 'History'
    }, // previous version of this part.
});
export interface IPartModel extends IPart, Document{}
export const Part:Model<IPartModel> = mongoose.model('Part', PartSchema, 'parts');

/**
 * PartsIdCounter
 */
export const PartsIdCounterSchema = new Schema({
  name: String,
  count: Number,
});
export const PartsIdCounter = mongoose.model('PartsIdCounter', PartsIdCounterSchema, 'part_id_counters');

/**
 * FileData
 */
const FileDataSchema = new Schema({
  name: String,   // original file name, 
  contentType: String,  // MIME type
  size: Number,   // bytes
  data: Buffer,   // data in binary
})
export interface IFileDataSchemaModel extends IFileData, Document{}
export const FileData:Model<IFileDataSchemaModel> = mongoose.model('FileData', FileDataSchema, 'file_data');

/**
 * PartDeletionRequest
 */
export const PartDeletionRequestSchema = new Schema({
  sender: {
    type:  Schema.Types.ObjectId,
    ref: 'User',
  },
  senderName: String,
  partId: Schema.Types.ObjectId,
  requestedCount: Number,
  requestedAt: [Date],
});
export const PartDeletionRequest = mongoose.model('PartDeletionRequest', PartDeletionRequestSchema, 'part_deletion_requests');

/**
 * Container
 */
export const ContainerSchema = new Schema({
    ctype: String,  //'tube'|'well'
    barcode: String,
    createdAt: Date,
    assignedAt: Date,
    
    operator: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    part: {
      type: Schema.Types.ObjectId,
      ref: 'Part',
    },

    parentContainer: {
      type: Schema.Types.ObjectId,
      ref: 'ContainerGroup',
    },

    wellId: Number,
    wellName: String,

    location: {
      type: Schema.Types.ObjectId,
      ref: 'Location',
    },
    verifiedAt: Date,

    locationHistory: [{
      location: {
        type: Schema.Types.ObjectId,
        ref: 'Location',
      },
      verifiedAt: Date,
    }],

    currentStatus: String,
});
export interface IContainerModel extends IContainer, Document{}
export const Container:Model<IContainerModel> = mongoose.model('Container', ContainerSchema, 'containers');

/**
 * ContainerGroup
 */
export const ContainerGroupSchema = new Schema({
  ctype: String, //'plate'|'rack'
  barcode: String,
  createdAt: Date,
  verifiedAt: Date,
  currentStatus: String,

  location: {
    type: Schema.Types.ObjectId,
    ref: 'Location',
  },

  locationHistory: [{
    location: {
      type: Schema.Types.ObjectId,
      ref: 'Location',
    },
    verifiedAt: Date,
  }],
});
export interface IContainerGroupModel extends IContainerGroup, Document{}
export const ContainerGroup:Model<IContainerGroupModel> = mongoose.model('ContainerGroup', ContainerGroupSchema, 'container_groups');


export const PartHistorySchema = new Schema({
  partId: Schema.Types.ObjectId,
  histories: [Schema.Types.Mixed],
});
export interface IPartHistoryModel extends IPartHistory, Document{}
export const PartHistory:Model<IPartHistoryModel> = mongoose.model('PartHistory', PartHistorySchema, 'part_histories');

export const LocationSchema = new Schema({
  barcode: String,
  description: String,
});

export interface ILocationModel extends ILocation, Document{}
export const Location:Model<ILocationModel> = mongoose.model('Location', LocationSchema);

export const LocationHistorySchema = new Schema({
  containerBarcode: String,
  locationBarcode: String,
})

export const LocationHistory = mongoose.model('LocationHistory', ContainerSchema, 'location_histories');

export const PersonalPickListSchema = new Schema({
  name: String,
  owner: {
    type: Schema.Types.ObjectId,
    ref: 'User',
  },
  createdAt: Date,
  updatedAt: Date,
  parts: [{
    type: Schema.Types.ObjectId,
    ref: 'Part',
  }],
  partsCount: Number,
  default: Boolean,
});
export interface IPersonalPickListModel extends IPersonalPickList, Document{}

export const PersonalPickList:Model<IPersonalPickListModel> = mongoose.model('PersonalPickList', PersonalPickListSchema, 'personal_pickLists');

export const TubesInRackScannerRecordSchema = new Schema({
  wellName: String,
  wellId: Number,
  barcode: String,
}, {_id: false});

export const RackScannerRecordSchema = new Schema({
  createdAt: Date,
  rackBarcode: String,
  tubes: [TubesInRackScannerRecordSchema],
});

export interface RackScannerRecordModel extends IRackScannerRecord, Document{}

export const RackScannerRecord:Model<RackScannerRecordModel> = mongoose.model('RackScannerRecord', RackScannerRecordSchema, 'rack_scanner_records');

export const CommentSchema = new Schema({
  part: {
    type: Schema.Types.ObjectId,
    ref: 'Part',
  },
  text: String,
  attachments: [{
    type: Schema.Types.ObjectId,
    ref: 'FileData',
  }],
  author: {
    type: Schema.Types.ObjectId,
    ref: 'User',
  },
  createdAt: Date,
  reference: {
    type: Schema.Types.ObjectId,
    ref: 'Comment',
  },
});
export interface IComment {
  part: string | IPart,
  text: string,
  attachments: string[]|IFileData[],
  author: string | IUser,
  createdAt: Date,
  reference: string | IComment,

}
export interface ICommentModel extends IComment, Document{}
export const Comment:Model<ICommentModel> = mongoose.model('Comment', CommentSchema, 'comments');